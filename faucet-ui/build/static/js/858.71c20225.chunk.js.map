{"version":3,"file":"static/js/858.71c20225.chunk.js","mappings":"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","sources":["../node_modules/viem/errors/ccip.ts","../node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = ErrorType\n\nexport async function offchainLookup<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType = ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":["OffchainLookupError","callbackSelector","cause","data","extraData","sender","urls","shortMessage","metaMessages","length","map","url","getUrl","flat","Object","BaseError","OffchainLookupResponseMalformedError","result","stringify","OffchainLookupSenderMismatchError","to","isAddressEqual","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase","offchainLookupSignature","offchainLookupAbiItem","name","type","inputs","offchainLookup","client","blockNumber","blockTag","decodeErrorResult","abi","args","callData","ccipRead","ccipRequest_","request","ccipRequest","call","concat","encodeAbiParameters","data_","error","Error","i","method","includes","body","undefined","fetch","replace","JSON","response","headers","get","startsWith","json","text","ok","HttpRequestError","details","statusText","status","isHex","message"],"sourceRoot":""}